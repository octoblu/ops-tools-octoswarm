#!/bin/bash

SCRIPT_NAME="octoswarm"
STACK_CONFIG_PATH="$PWD/cluster.json"

usage(){
  echo "USAGE: $SCRIPT_NAME <subcommand>"
  echo 'Description: swarms of octos!'
  echo ''
  echo 'Arguments:'
  echo '  -h, --help        print this help text'
  echo '  -v, --version     print the version'
  echo '  -u, --upgrade     upgrade to the latest version of octoswarm'
  echo 'Environment:'
  echo '  DEBUG             print debug output'
}

version(){
  local directory
  directory="$(script_directory)"

  if [ -f "${directory}/VERSION" ]; then
    cat "${directory}/VERSION"
  else
    echo "unknown-version"
  fi
}

script_directory(){
  local source="${BASH_SOURCE[0]}"
  local dir=""

  while [ -h "$source" ]; do # resolve $source until the file is no longer a symlink
    dir="$( cd -P "$( dirname "$source" )" && pwd )"
    source="$(readlink "$source")"
    [[ $source != /* ]] && source="$dir/$source" # if $source was a relative symlink, we need to resolve it relative to the path where the symlink file was located
  done

  dir="$( cd -P "$( dirname "$source" )" && pwd )"

  echo "$dir"
}

fatal() {
  local message="$@"
  errecho "Error: $message"
  exit 1
}

errecho() {
  local message="$@"
  (>&2 echo -e "$message")
}

assert_cluster_json() {
  if [ ! -f "$STACK_CONFIG_PATH" ]; then
    fatal "octoswarm must be run in a folder with a cluster.json"
  fi
}

assert_required_config() {
  local docker_version
  docker_version="$(get_docker_version)"
  if [ "$docker_version" == "null" ]; then
    fatal "octoswarm docker version not specified, exiting."
  fi
}

assert_required_env() {
  if [ -z "$OCTOSWARM_GITHUB_API_TOKEN" ]; then
    fatal "Missing required env OCTOSWARM_GITHUB_API_TOKEN"
  fi
}

assert_versions() {
  local docker_version="$1"
  local latest_version="$2"
  if [ -z "$docker_version" ] || [ "$docker_version" == "null" ]; then
    fatal "Missing '.octoswarm.dockerVersion' in cluster.json"
  fi
  if [ -z "$latest_version" ] || [ "$latest_version" == "null" ]; then
    fatal "Unable to retrieve latest version of octoswarm"
  fi
}

get_docker_version() {
  jq --raw-output '.octoswarm.dockerVersion' "$STACK_CONFIG_PATH"
}

get_binary_name() {
  local docker_version
  docker_version="$(get_docker_version)"
  echo "octoswarm-$docker_version"
}

get_whalebrew_image() {
  local docker_version
  local latest_version
  docker_version="$(get_docker_version)"
  latest_version="$(get_latest_version)"
  assert_versions "$docker_version" "$latest_version"
  echo "octoblu/octoswarm:$docker_version-$latest_version"
}

get_latest_version() {
  curl --fail --silent "https://sqrtofsaturn:$OCTOSWARM_GITHUB_API_TOKEN@api.github.com/repos/octoblu/octoswarm/releases/latest" | jq --raw-output '.tag_name'
}

main() {
  local upgrade
  case "$1" in
    -h | --help)
      usage
      exit 0
      ;;
    -v | --version)
      version
      exit 0
      ;;
    -u | --upgrade)
      upgrade='true'
      shift
      ;;
  esac

  local args="$@"
  assert_cluster_json
  assert_required_config
  assert_required_env
  local binary_name
  binary_name="$(get_binary_name)"

  if [ "$upgrade" == "true" ]; then
    echo "Uninstalling $binary_name from whalebrew"
    whalebrew uninstall "$binary_name" 2> /dev/null
  fi

  if [ -z "$(which "$binary_name" 2> /dev/null)" ]; then
    local whalebrew_image
    whalebrew_image="$(get_whalebrew_image)"
    if [ "$?" != "0" ]; then
      errecho "$whalebrew_image"
      exit 1
    fi
    echo "Installing $whalebrew_image from whalebrew"
    whalebrew install "$whalebrew_image" \
      && echo "$whalebrew_image installed" \
      || fatal "Unable to install $whalebrew_image, cowardly refusing to do anything."
  fi

  if [ -z "$args" ]; then
    echo ''
    usage
    exit 1
  fi

  $binary_name $args
}

main "$@"
